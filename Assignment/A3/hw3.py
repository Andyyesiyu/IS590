#!/usr/bin/env python
# -*- coding: utf-8 -*-
import random


# Point definition
#   - prev: For solution member, indicating the previous point. `None` for start point, e.g. (x, y)
#   - dirToNxt: For solution member, indicating the direction it is pointing to the next point, e.g. 'n'
#   - nxt: For solution member, indicating the next point. `None` for end point, e.g. (x, y)
#   - arrows: A `string` list storing all available arrows at current point.
#       - arrows are strings representing the direction it's pointing
#       - 12 types in total: e, w ,s ,n, se, sw, wn, ws, ne, nw, en, es
class Point:
    def __init__(self, prev, dirToNxt, nxt, arrows):
        self.prev = prev
        self.dirToNxt = dirToNxt
        self.nxt = nxt
        self.arrows = arrows


# pairMap:
# For checking the pair that would generate unexpected new arrows
pairMap = {
    "ws": ["se", "n", "nw"],
    "wn": ["ne", "s", "sw"],
    "ne": ["wn", "w", "es"],
    "es": ["ne", "n", "sw"],
    "se": ["en", "w", "ws"],
    "en": ["se", "s", "nw"],
    "sw": ["wn", "e", "es"],
    "nw": ["ws", "e", "en"],
    "n": ["ws", "es"],
    "s": ["wn", "en"],
    "w": ["ne", "se"],
    "e": ["sw", "nw"]
}


# outcomeMap:
# For checking the extra outcome generated by the combinations of certain arrows
outcomeMap = {
    ('se', 'ws'): 'es',
    ('ne', 'ne'): 'en',
    ('es', 'ne'): 'se',
    ('en', 'se'): 'ne',
    ('se', 'wn'): 'nw',
    ('nw', 'ws'): 'sw',
    ('en', 'nw'): 'wn',
    ('es', 'sw'): 'ws',
    ('n', 'ws'): 's',
    ('es', 'n'): 's',
    ('s', 'wn'): 'n',
    ('en', 's'): 'n',
    ('ne', 'w'): 'e',
    ('se', 'w'): 'e',
    ('e', 'sw'): 'w',
    ('e', 'nw'): 'w'
}


def printPuzzle(points):
    a = ""
    for i in range(len(points)):
        for j in range(len(points[i])):
            currPoint = points[i][j]
            if not currPoint.arrows:
                a += 'null' + '\t'
            else:
                a += ','.join(currPoint.arrows) + '\t'
        a += '\n'
    print(a)


def initPoints(width, height):
    points = []
    for _ in range(height):
        row = []
        for _ in range(width):
            row.append(Point(None, None, None, []))
        points.append(row)
    return points


# directMap:
# For quickly getting the type of arrow depending on prev direction and next direction
directMap = {
    ("n", "n"): "n",
    ("e", "e"): "e",
    ("s", "s"): "s",
    ("w", "w"): "w",
    ("n", "e"): "se",
    ("n", "w"): "sw",
    ("s", "e"): "ne",
    ("s", "w"): "nw",
    ("e", "n"): "wn",
    ("e", "s"): "ws",
    ("w", "n"): "en",
    ("w", "s"): "es"
}


# Find repeated path in generate phase
# Check if U turn and newMove enter main result route
# points[newMove].prev = current, return True
def checkValidation(points, current, newMove, dirToNew, width, height):
    # Check if start point
    if not points[current[0]][current[1]].prev:
        return True

    # Check U turn
    if points[current[0]][current[1]].prev == newMove:
        return False

    # Check on route
    if not points[newMove[0]][newMove[1]].nxt:
        return True

    # Check if corner/edge
    if newMove[0] == 0 or newMove[0] == height - 1 or newMove[1] == 0 or newMove[1] == width - 1:
        return False

    # Check into solution
    if directMap[(dirToNew, points[newMove[0]][newMove[1]].dirToNxt)] in points[newMove[0]][newMove[1]].arrows:
        return False

    return True


# Our puzzle will always start from the left border and ends on the right border for simplicity
# This feature has little impact on the puzzle difficulty as the remaining parts for determining the solution are all random
# The direction of next step is randomly generated:
#   0 for up, 1 for right, 2 for down, 3 for left
def findValidMove(points, current, width, height):
    # check whether in a line, whether conflict with
    validMoveList = []
    if current[0] - 1 >= 0:
        newMove = (current[0] - 1, current[1])
        if checkValidation(points, current, newMove, 'n', width, height):
            validMoveList.append(newMove)
    if current[0] + 1 < width:
        newMove = (current[0] + 1, current[1])
        if checkValidation(points, current, newMove, 's', width, height):
            validMoveList.append(newMove)
    if current[1] - 1 >= 0:
        newMove = (current[0], current[1] - 1)
        if checkValidation(points, current, newMove, 'w', width, height):
            validMoveList.append(newMove)
    if current[1] + 1 < height:
        newMove = (current[0], current[1] + 1)
        if checkValidation(points, current, newMove, 'e', width, height):
            validMoveList.append(newMove)

    return validMoveList


def getDirection(current, nextMove):
    if current[0] != nextMove[0]:
        if current[0] - nextMove[0] == -1:
            return "s"
        if current[0] - nextMove[0] == 1:
            return "n"
    if current[1] != nextMove[1]:
        if current[1] - nextMove[1] == -1:
            return "e"
        if current[1] - nextMove[1] == 1:
            return "w"
    return "nonsense"


# Push new arrows into a point
# Take care of those might be generated by accident, which are listed in `outcomeMap`
def pushArrow(points, current, arrow):
    arrowList = [arrow]
    while len(arrowList) > 0:
        candidate = arrowList.pop(0)
        if candidate not in points[current[0]][current[1]].arrows:
            points[current[0]][current[1]].arrows.append(candidate)

        # Check if any additional arrow after appending candidate
        for targetArr in pairMap[candidate]:
            if targetArr in points[current[0]][current[1]].arrows:
                try:
                    addtionArrow = outcomeMap[tuple(
                        sorted([targetArr, arrow]))]
                    arrowList.append(addtionArrow)
                except:
                    pass
    return


def visitBlocks(visitedBlock, curernt, dirToNxt, width, height):
    toCheckBlock = []
    if dirToNxt == "s":
        toCheckBlock.append((curernt[0], curernt[1]-1))
        toCheckBlock.append((curernt[0], curernt[1]+1))
    if dirToNxt == "n":
        toCheckBlock.append((curernt[0]-1, curernt[1]-1))
        toCheckBlock.append((curernt[0]-1, curernt[1]+1))
    if dirToNxt == "e":
        toCheckBlock.append((curernt[0]-1, curernt[1]))
        toCheckBlock.append((curernt[0]+1, curernt[1]))
    if dirToNxt == "w":
        toCheckBlock.append((curernt[0]-1, curernt[1]-1))
        toCheckBlock.append((curernt[0]+1, curernt[1]-1))

    for i, j in toCheckBlock:
        if 0 <= i < width-1 and 0 <= j < height-1:
            visitedBlock[i][j] = True

    return all([all(i) for i in visitedBlock])


def findSolution(points, width, height):
    randStartRow = random.randint(0, len(points[0]) - 1)
    start = (randStartRow, 0)
    current = start
    points[current[0]][0]
    finished = False
    solution = []
    route = []
    visitedBlock = [[False for _ in range(width-1)] for _ in range(height-1)]
    allBlockVisited = False

    while not finished:
        # Get all valid moves and randomly pick one
        validMovelist = findValidMove(points, current, width, height)
        if not validMovelist:
            return None, None, None, False
        print("validMovelist = ", validMovelist)
        print("current = ", current)
        nextMove = random.choice(validMovelist)
        print("nextMove = ", nextMove)
        points[nextMove[0]][nextMove[1]].prev = current
        print("UpdatedPrev = ", points[nextMove[0]][nextMove[1]].prev)
        points[current[0]][current[1]].next = nextMove
        dirToNxt = getDirection(current, nextMove)
        points[current[0]][current[1]].dirToNxt = dirToNxt

        # Get  the direction from current point to the picked move and get the corresponding arrow
        if points[current[0]][current[1]].prev:
            prev0 = points[current[0]][current[1]].prev[0]
            prev1 = points[current[0]][current[1]].prev[1]
            arrow = directMap[points[prev0][prev1].dirToNxt, dirToNxt]
        else:
            arrow = directMap[dirToNxt, dirToNxt]
        pushArrow(points, current, arrow)

        # TODO: update `finished` once nextMove is found, add `allBlockVisited` for checking whether finished
        # Visit block
        allBlockVisited = visitBlocks(
            visitedBlock, current, dirToNxt, width, height)
        print("allBlockVisited = ", allBlockVisited)
        if allBlockVisited and ((nextMove[1] == width - 1 or nextMove[1] == 0 or nextMove[0] == 0 or nextMove[0] == height - 1) and nextMove != start):
            finished = True

        route.append(current)
        current = nextMove
        solution.append(dirToNxt)

    # Generate arrow for endpoint
    prev0 = points[current[0]][current[1]].prev[0]
    prev1 = points[current[0]][current[1]].prev[1]
    if current[0] == 0:
        dirToNxt = "n"
    if current[0] == height - 1:
        dirToNxt = "s"
    if current[1] == 0:
        dirToNxt = "w"
    if current[1] == width - 1:
        dirToNxt = "e"
    arrow = directMap[points[prev0][prev1].dirToNxt, dirToNxt]
    pushArrow(points, current, arrow)
    solution.append(dirToNxt)
    route.append(current)

    return start, solution, route, True


# TODO: implement `fillRemPoints`
# This function should fill all the points, including those in solution route with all valid arrows that will not creat another valid path from start to the end.
def fillRemPoints(points):
    return


def generatePuzzle(width, height):
    success = False
    while not success:
        points = initPoints(width, height)
        start, solution, route, success = findSolution(points, width, height)
        # fillRemPoints(points)
    return points, start, solution, route


if __name__ == "__main__":
    width = 4
    height = 4

    points, start, solution, route = generatePuzzle(width, height)
    printPuzzle(points)
    print(start, solution, route)
